<?xml version='1.0' encoding='UTF-8' ?>
<!-- Created by Uniface - (C) Uniface B.V. All rights reserved -->
<!DOCTYPE UNIFACE PUBLIC "UNIFACE.DTD" "UNIFACE.DTD">
<UNIFACE release="9.6" xmlengine="2.0">
<TABLE>
<DSC name="ULIBR" model="DICT" system="S" pseudo ="73" level="1" noupdate="0"
 rbk="0" ffsql="0" transnr="0" segsize="0" ufocc="0" charset=".U">
<FLD name="ULIBRARY" seqno="1" type="S" level="2" pack="0" scale="0" length="16"
 pointer="0" inum="1" ufocc="0" mandatory="yes" idxnum="1" idxsnr="101" />
<FLD name="UDESCR" seqno="2" type="S" level="2" pack="0" scale="0" length="25"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UTIMESTAMP" seqno="3" type="E" level="2" pack="0" scale="0" length="15"
 pointer="0" inum="0" ufocc="0" />
</DSC>
<OCC>
<DAT name="ULIBRARY">USTRING</DAT>
<DAT name="UDESCR" xml:space='preserve'>String library</DAT>
<DAT name="UTIMESTAMP">2014-10-19T17:35:14.00</DAT>
</OCC>
</TABLE>
<TABLE>
<DSC name="USOURCE" model="DICT" system="S" pseudo ="73" level="1" noupdate="0"
 rbk="0" ffsql="0" transnr="0" segsize="0" ufocc="500" charset=".U">
<FLD name="UTIMESTAMP" seqno="1" type="E" level="2" pack="0" scale="0" length="15"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UCOMPSTAMP" seqno="2" type="E" level="2" pack="0" scale="0" length="15"
 pointer="0" inum="0" ufocc="0" />
<FLD name="USTAT" seqno="3" type="S" level="2" pack="0" scale="0" length="1"
 pointer="0" inum="0" ufocc="0" />
<FLD name="USUB" seqno="4" type="S" level="2" pack="0" scale="0" length="1"
 pointer="0" inum="2" ufocc="0" mandatory="yes" idxnum="1,2" idxsnr="101,1" />
<FLD name="UVAR" seqno="5" type="S" level="2" pack="0" scale="0" length="16"
 pointer="0" inum="2" ufocc="0" mandatory="yes" idxnum="1,2" idxsnr="102,2" />
<FLD name="ULABEL" seqno="6" type="S" level="2" pack="0" scale="0" length="16"
 pointer="0" inum="1" ufocc="0" mandatory="yes" idxnum="1" idxsnr="103" />
<FLD name="ULAN" seqno="7" type="S" level="2" pack="0" scale="0" length="3"
 pointer="0" inum="1" ufocc="0" mandatory="yes" idxnum="1" idxsnr="104" />
<FLD name="MSGTYPE" seqno="8" type="S" level="2" pack="0" scale="0" length="1"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UVERS" seqno="9" type="S" level="2" pack="0" scale="0" length="12"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UDESCR" seqno="10" type="S" level="2" pack="0" scale="0" length="25"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UVPOS" seqno="11" type="S" level="2" pack="0" scale="0" length="6"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UHPOS" seqno="12" type="S" level="2" pack="0" scale="0" length="6"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UVSIZ" seqno="13" type="S" level="2" pack="0" scale="0" length="6"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UHSIZ" seqno="14" type="S" level="2" pack="0" scale="0" length="6"
 pointer="0" inum="0" ufocc="0" />
<FLD name="AUTHORIZ" seqno="15" type="S" level="2" pack="0" scale="0" length="1"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UCLASS" seqno="16" type="S" level="2" pack="0" scale="0" length="1"
 pointer="0" inum="0" ufocc="0" />
<FLD name="LOCREF" seqno="17" type="S" level="2" pack="0" scale="0" length="1"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UCONFIRM" seqno="18" type="B" level="2" pack="0" scale="0" length="1"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UAUDIO" seqno="19" type="N" level="2" pack="10" scale="0" length="1"
 pointer="0" inum="0" ufocc="0" />
<FLD name="UCOMMENT" seqno="20" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",0,0,0,,1,0,1,\1D,0,0,0,," />
<FLD name="UTEXT" seqno="21" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,1,\1E,0,0,0,,0,0,0,," />
<FLD name="UWLEVEL" seqno="22" type="S" level="2" pack="141" scale="0" length="0"
 pointer="0" inum="0" ufocc="0" varinfo=",1,0,2,\1F\C1,0,0,0,,0,0,0,," />
</DSC>
<OCC>
<DAT name="UTIMESTAMP">2014-10-31T14:55:11.00</DAT>
<DAT name="USUB">I</DAT>
<DAT name="UVAR">USTRING</DAT>
<DAT name="ULABEL">ALPHABET2NUMBER</DAT>
<DAT name="ULAN">P</DAT>
<DAT name="UTEXT" xml:space='preserve'>entry alphabet2Number
   ; @description = convert a char value to its numeric location in the alfabet
   ; @author = Dennis E.J. Vorst 
   ; @issues = put the items in list with key value pairs
   params 
      string  p_char  : in
      numeric p_value : out
   endparams 
   variables 
      string v_ftlist
   endvariables 

   if (p_char = "")
      p_value = -1
      return(0)
   endif

   putitem/id v_ftlist, "A", 1
   putitem/id v_ftlist, "B", 2
   putitem/id v_ftlist, "C", 3
   putitem/id v_ftlist, "D", 4
   putitem/id v_ftlist, "E", 5
   putitem/id v_ftlist, "F", 6
   putitem/id v_ftlist, "G", 7
   putitem/id v_ftlist, "H", 8
   putitem/id v_ftlist, "I", 9
   putitem/id v_ftlist, "J", 10
   putitem/id v_ftlist, "K", 11
   putitem/id v_ftlist, "L", 12
   putitem/id v_ftlist, "M", 13
   putitem/id v_ftlist, "N", 14
   putitem/id v_ftlist, "O", 15
   putitem/id v_ftlist, "P", 16
   putitem/id v_ftlist, "Q", 17
   putitem/id v_ftlist, "R", 18
   putitem/id v_ftlist, "S", 19
   putitem/id v_ftlist, "T", 20
   putitem/id v_ftlist, "U", 21
   putitem/id v_ftlist, "V", 22
   putitem/id v_ftlist, "W", 23
   putitem/id v_ftlist, "X", 24
   putitem/id v_ftlist, "Y", 25
   putitem/id v_ftlist, "Z", 26

   p_value = $item(p_char, v_ftlist)

   return(0)
end ; alphabet2Number
</DAT>
</OCC>
<OCC>
<DAT name="UTIMESTAMP">2014-10-19T20:01:03.00</DAT>
<DAT name="USUB">I</DAT>
<DAT name="UVAR">USTRING</DAT>
<DAT name="ULABEL">ASCII2CHAR</DAT>
<DAT name="ULAN">P</DAT>
<DAT name="UDESCR" xml:space='preserve'>ASCII to character</DAT>
<DAT name="UTEXT" xml:space='preserve'>entry ascii2Char
   ; @description = convert a numeric value to its char equivalent
   ; @author = Dennis E.J. Vorst 
   params 
      numeric p_value : in 
      string  p_char  : out
   endparams

   selectcase p_value
      case 32
         p_char = " "
      case 33
         p_char = "!"
      case 34
         p_char = "%%""
      case 35
         p_char = "#"
      case 36
         p_char = "$"
      case 37
         p_char = "%"
      case 38
         p_char = "&amp;"
      case 39
         p_char = "'"
      case 40
         p_char = "("
      case 41
         p_char = ")"
      case 42
         p_char = "*"
      case 43
         p_char = "+"
      case 44
         p_char = ","
      case 45
         p_char = "-"
      case 46
         p_char = "."
      case 47
         p_char = "/"
      case 48
         p_char = "0"
      case 49
         p_char = "1"
      case 50
         p_char = "2"
      case 51
         p_char = "3"
      case 52
         p_char = "4"
      case 53
         p_char = "5"
      case 54
         p_char = "6"
      case 55
         p_char = "7"
      case 56
         p_char = "8"
      case 57
         p_char = "9"
      case 58
         p_char = ":"
      case 59
         p_char = ";"
      case 60
         p_char = "&lt;"
      case 61
         p_char = "="
      case 62
         p_char = "&gt;"
      case 63
         p_char = "?"
      case 64
         p_char = "@"
      case 65
         p_char = "A"
      case 66
         p_char = "B"
      case 67
         p_char = "C"
      case 68
         p_char = "D"
      case 69
         p_char = "E"
      case 70
         p_char = "F"
      case 71
         p_char = "G"
      case 72
         p_char = "H"
      case 73
         p_char = "I"
      case 74
         p_char = "J"
      case 75
         p_char = "K"
      case 76
         p_char = "L"
      case 77
         p_char = "M"
      case 78
         p_char = "N"
      case 79
         p_char = "O"
      case 80
         p_char = "P"
      case 81
         p_char = "Q"
      case 82
         p_char = "R"
      case 83
         p_char = "S"
      case 84
         p_char = "T"
      case 85
         p_char = "U"
      case 86
         p_char = "V"
      case 87
         p_char = "W"
      case 88
         p_char = "X"
      case 89
         p_char = "Y"
      case 90
         p_char = "Z"
      case 91
         p_char = "["
      case 92
         p_char = "\"
      case 93
         p_char = "]"
      case 94
         p_char = "^"
      case 95
         p_char = "_"
      case 96
         p_char = "`"
      case 97
         p_char = "a"
      case 98
         p_char = "b"
      case 99
         p_char = "c"
      case 100
         p_char = "d"
      case 101
         p_char = "e"
      case 102
         p_char = "f"
      case 103
         p_char = "g"
      case 104
         p_char = "h"
      case 105
         p_char = "i"
      case 106
         p_char = "j"
      case 107
         p_char = "k"
      case 108
         p_char = "l"
      case 109
         p_char = "m"
      case 110
         p_char = "n"
      case 111
         p_char = "o"
      case 112
         p_char = "p"
      case 113
         p_char = "q"
      case 114
         p_char = "r"
      case 115
         p_char = "s"
      case 116
         p_char = "t"
      case 117
         p_char = "u"
      case 118
         p_char = "v"
      case 119
         p_char = "w"
      case 120
         p_char = "x"
      case 121
         p_char = "y"
      case 122
         p_char = "z"
      case 123
         p_char = "{"
      case 124
         p_char = "|"
      case 125
         p_char = "}"
      case 126
         p_char = "~"
      elsecase
         message "Ascii value not recognized or value entered lower than 32 or higher than 127 (system information reference)"

      
   endselectcase
   return(0)
end ; ascii2Char</DAT>
</OCC>
<OCC>
<DAT name="UTIMESTAMP">2014-10-19T20:01:03.00</DAT>
<DAT name="USUB">I</DAT>
<DAT name="UVAR">USTRING</DAT>
<DAT name="ULABEL">CHAR2ASCII</DAT>
<DAT name="ULAN">P</DAT>
<DAT name="UDESCR" xml:space='preserve'>Character to ascii</DAT>
<DAT name="UTEXT" xml:space='preserve'>entry char2Ascii
   ; @description = convert a numeric value to its char equivalent
   ; @author = Dennis E.J. Vorst 
   ; @issues = put the items in a list and then filter them
   params 
      string  p_char  : in
      numeric p_value : out 
   endparams

   selectcase p_char
      case " "
         p_value = 32
      case "!"
         p_value = 33
      case "%%""
         p_value = 34
      case "#"
         p_value = 35
      case "$"
         p_value = 36
      case "%"
         p_value = 37
      case "&amp;"
         p_value = 38
      case "'"
         p_value = 39
      case "("
         p_value = 40
      case ")"
         p_value = 41
      case "*"
         p_value = 42
      case "+"
         p_value = 43
      case ","
         p_value = 44
      case "-"
         p_value = 45
      case "."
         p_value = 46
      case "/"
         p_value = 47
      case "0"
         p_value = 48
      case "1"
         p_value = 49
      case "2"
         p_value = 50
      case "3"
         p_value = 51
      case "4"
         p_value = 52
      case "5"
         p_value = 53
      case "6"
         p_value = 54
      case "7"
         p_value = 55
      case "8"
         p_value = 56
      case "9"
         p_value = 57
      case ":"
         p_value = 58
      case ";"
         p_value = 59
      case "&lt;"
         p_value = 60
      case "="
         p_value = 61
      case "&gt;"
         p_value = 62
      case "?"
         p_value = 63
      case "@"
         p_value = 64
      case "A"
         p_value = 65
      case "B"
         p_value = 66
      case "C"
         p_value = 67
      case "D"
         p_value = 68
      case "E"
         p_value = 69
      case "F"
         p_value = 70
      case "G"
         p_value = 71
      case "H"
         p_value = 72
      case "I"
         p_value = 73
      case "J"
         p_value = 74
      case "K"
         p_value = 75
      case "L"
         p_value = 76
      case "M"
         p_value = 77
      case "N"
         p_value = 78
      case "O"
         p_value = 79
      case "P"
         p_value = 80
      case "Q"
         p_value = 81
      case "R"
         p_value = 82
      case "S"
         p_value = 83
      case "T"
         p_value = 84
      case "U"
         p_value = 85
      case "V"
         p_value = 86
      case "W"
         p_value = 87
      case "X"
         p_value = 88
      case "Y"
         p_value = 89
      case "Z"
         p_value = 90
      case "["
         p_value = 91
      case "\"
         p_value = 92
      case "]"
         p_value = 93
      case "^"
         p_value = 94
      case "_"
         p_value = 95
      case "`"
         p_value = 96
      case "a"
         p_value = 97
      case "b"
         p_value = 98
      case "c"
         p_value = 99
      case "d"
         p_value = 100
      case "e"
         p_value = 101
      case "f"
         p_value = 102
      case "g"
         p_value = 103
      case "h"
         p_value = 104
      case "i"
         p_value = 105
      case "j"
         p_value = 106
      case "k"
         p_value = 107
      case "l"
         p_value = 108
      case "m"
         p_value = 109
      case "n"
         p_value = 110
      case "o"
         p_value = 111
      case "p"
         p_value = 112
      case "q"
         p_value = 113
      case "r"
         p_value = 114
      case "s"
         p_value = 115
      case "t"
         p_value = 116
      case "u"
         p_value = 117
      case "v"
         p_value = 118
      case "w"
         p_value = 119
      case "x"
         p_value = 120
      case "y"
         p_value = 121
      case "z"
         p_value = 122
      case "{"
         p_value = 123
      case "|"
         p_value = 124
      case "}"
         p_value = 125
      case "~"
         p_value = 126
      elsecase
         message "Char value not recognized"
   endselectcase
   return(0)
end ; char2Ascii
</DAT>
</OCC>
<OCC>
<DAT name="UTIMESTAMP">2014-10-19T17:43:48.00</DAT>
<DAT name="USUB">I</DAT>
<DAT name="UVAR">USTRING</DAT>
<DAT name="ULABEL">CHECKCASE</DAT>
<DAT name="ULAN">P</DAT>
<DAT name="UDESCR" xml:space='preserve'>Check the case of text</DAT>
<DAT name="UTEXT" xml:space='preserve'>entry checkCase
   ; @name = IP_CHE_CASE
   ; @description = Check the case of the given string. 
   ; @params = p_string can be any string. p_case can be either UPPER, LOWER or CAMEL. p_found returns true if the string complies with the p_case entered.
   ; @deprecated 
   ; @additiobal = this function is deprecated. Please use the function in the service S_MIS_OBJECt
   ; @version = 0.1
   ; @date = 2014-01-08
   ; @author = Dennis E.J. Vorst
   ; 
   params
      string  p_string  : in 
      string  p_case    : in
      boolean p_isfound : out
   endparams

   ; prerequisites
   if (p_string = "")
;      message/nobeep "IP_CHE_CASE - Empty string."
      p_isfound = 1
      return(0)
   endif 
   if (p_case = "")
      ; if the case is empty we automatically comply
;      message/nobeep "IP_CHE_CASE - Empty case."
      p_isfound = 1
      return(0)
   endif 

   ; init 
   p_isfound = 0

   ; the actual checking 
   selectcase p_case 
      case "CAMEL"
         ; camelcase happens when the string is neither uppercase nor lowercase 
         ; example of camelcase: CamelCase
         if (p_string != $lowercase(p_string) &amp; p_string != $uppercase(p_string))
            p_isfound = 1
         endif 
      case "LOWER"
         if (p_string = $lowercase(p_string))
            p_isfound = 1
         endif 
      case "UPPER"
         if (p_string = $uppercase(p_string))
            p_isfound = 1
         endif 
      elsecase 
         debug
         message/nobeep $concat("checkCase: Unknown case ", p_case)
         return(0)
   endselectcase 
   return(0)
end ; checkCase</DAT>
</OCC>
<OCC>
<DAT name="UTIMESTAMP">2014-10-19T17:43:48.00</DAT>
<DAT name="USUB">I</DAT>
<DAT name="UVAR">USTRING</DAT>
<DAT name="ULABEL">COUNTSTRING</DAT>
<DAT name="ULAN">P</DAT>
<DAT name="UDESCR" xml:space='preserve'>Count the string</DAT>
<DAT name="UTEXT" xml:space='preserve'>entry countString
   ; @description = Count the number of times a string is found in another string.
   ; @params = p_string can be any string. p_case can be either UPPER, LOWER or CAMEL. p_found returns true if the string complies with the p_case entered.
   ; @version = 0.1
   ; @date = 2014-01-08
   ; @author = Dennis E.J. Vorst
   ; 
   params
      string  p_string : in 
      string  p_search : in
      boolean p_case   : in
      numeric p_found  : out
   endparams
   variables 
      numeric v_pointer, v_length
   endvariables 

   ; prerequisites 
   if (p_string = "")
;      message/nobeep "IP_COUNT_STRING - Empty string."
      return(0)
   endif 
   if (p_search = "")
;      message/nobeep "IP_COUNT_STRING - Empty case."
      return(0)
   endif
   ; not case sensitive  
   if (!p_case)
      p_string = $uppercase(p_string)
      p_search = $uppercase(p_search)
   endif 

   ; init 
   p_found = 0
   v_length = $length(p_search)

   ; the actual checking 
   while (p_string != "")
      v_pointer = $scan(p_string, p_search)
      if (v_pointer &gt; 0)
         p_found +=1
         p_string = p_string[v_pointer + v_length + 1]
      else 
         p_string = ""
      endif 
   endwhile 
   return(0)
end ; countString</DAT>
</OCC>
<OCC>
<DAT name="UTIMESTAMP">2014-10-19T17:38:05.00</DAT>
<DAT name="USUB">I</DAT>
<DAT name="UVAR">USTRING</DAT>
<DAT name="ULABEL">CUTSTRING</DAT>
<DAT name="ULAN">P</DAT>
<DAT name="UDESCR" xml:space='preserve'>Cut the string</DAT>
<DAT name="UTEXT" xml:space='preserve'>entry cutString
   ; @name = cutString
   ; @description = Cut a string into two pieces. One being the part between the search start and search end value. The other the remaining string concatenated. 
   ; @version = 0.1
   ; @author = Dennis E.J. Vorst
   params 
      string p_string_in    : in
      string p_search_start : in
      string p_search_end   : in
      string p_eol_char     : in
      string p_string_out   : out
      string p_cut_string   : out
   endparams 
   variables 
      numeric v_position, v_length
      string v_string_in
   endvariables 

   ; init 
   v_position  = $scan(p_string_in, p_search_start)
   v_length    = $length(p_search_end)
   v_string_in = p_string_in

   if (v_position &gt; 0)
      ; add the previous part of the trigger to a string for further processing 
      p_string_out = $concat(p_string_out, p_string_in[1, v_position - 1])
      ; cut the rest of the trigger from the starting point of the found stuff
      p_string_in = p_string_in[v_position]

      ; get the end part 
      v_position = $scan(p_string_in, p_search_end)
      ; if not found then put the rest in 
      if (v_position = 0)
         ; end string not found. Return the entire string 
         p_string_out = v_string_in
         p_cut_string = ""
      else 
         p_cut_string = p_string_in[1, v_position + v_length - 1]
         p_string_out = $concat(p_string_out, p_eol_char, p_string_in[v_position + v_length])
      endif
   else 
      ; searchstring is not found 
      p_string_out = p_string_in
      p_cut_string = ""

   endif

   return(0)
end ; cutString
</DAT>
</OCC>
<OCC>
<DAT name="UTIMESTAMP">2014-10-19T17:43:48.00</DAT>
<DAT name="USUB">I</DAT>
<DAT name="UVAR">USTRING</DAT>
<DAT name="ULABEL">GETLOCATIONS</DAT>
<DAT name="ULAN">P</DAT>
<DAT name="UDESCR" xml:space='preserve'>Get the locations</DAT>
<DAT name="UTEXT" xml:space='preserve'>entry getLocations	
   ; @description = Return a list of starting points in the string where a corresponding string is found.
   ; @params = p_string can be any string. p_case can be either true (case sensitive) or false (case insensitive). p_list contains the starting locations of the string.
   ; @version = 0.1
   ; @date = 2014-01-08
   ; @author = Dennis E.J. Vorst
   params
      string  p_string      : in 
      string  p_search      : in
      boolean p_bncase      : in ; yes is case sensitive; no is case insensitive 
      boolean p_bninliteral : in ; yes also look in literal string; false - donot look into literal string 
      string  p_list        : out ; a list with numbers with the found strings
   endparams
   variables 
      numeric v_pointer, v_length, v_counter, v_next_pointer
      string v_item
   endvariables 

   ; prerequisites 
   if (p_string = "")
;      message/nobeep "IP_STRING_LOCATIONS - Empty string."
      return(0)
   endif 
   if (p_search = "")
;      message/nobeep "IP_STRING_LOCATIONS - Empty case."
      return(0)
   endif
   ; when we split the string into literals and none literals there is not supposed to be a gold+; in it 
   ; just to be clear when the boolean is false 
   if (!p_bninliteral &amp; $scan(p_string, "&uSEP;") &gt; 0)
      debug
      message/nobeep "IP_STRING_LOCATIONS - String contains gold+;."
;      return(0)
   endif 

   ; 2014-03-03 there is an issue with lists in lists. So we replace the gold+! by a single !
   p_string = $replace(p_string, 1, "&uNOT;", "!", -1)

   ; not case sensitive  
   if (!p_bncase)
      p_string = $uppercase(p_string)
      p_search = $uppercase(p_search)
   endif 

   ; init 
   v_counter = 0
   v_length  = $length(p_search)

   ; locate the literals
   ; if we donot want to look in the literal string we need to identify them
   if (!p_bninliteral)
      call IP_SLICE_LITERALS(p_string, p_string)
      #include MATERIAL:ERR_CALL
   endif 

   ; the actual checking 
   forlist v_item in p_string

      ; save the next pointer, we need it after processing this substring 
      ; and add 1 for the eol character or the gold+;
      ; and 1 just to be sure
      v_next_pointer += $length(v_item) + 1
      ; process the substring 
      while (v_item != "")
         v_pointer = $scan(v_item, p_search)
         if (v_pointer &gt; 0)
            v_item = v_item[v_pointer + v_length]
            v_counter += v_pointer
            putitem p_list, -1, v_counter
            v_counter += v_length -1
;            v_counter += v_length
         else 
;            v_pointer += $length(v_item)
            v_counter += $length(v_item)
            v_item = ""
         endif 
      endwhile 
      ; reset the pointer
;      v_pointer = v_next_pointer
      v_counter = v_next_pointer
   endfor

   ; check the found values 
   forlist v_item in p_list 
      if ($uppercase(p_string[v_item, v_item + v_length -1]) != $uppercase(p_search))
         debug
         break
      endif 
   endfor

   return(0)
end ; getLocations</DAT>
</OCC>
<OCC>
<DAT name="UTIMESTAMP">2015-09-23T12:08:06.00</DAT>
<DAT name="USUB">I</DAT>
<DAT name="UVAR">USTRING</DAT>
<DAT name="ULABEL">GET_LEVENSHTEIN</DAT>
<DAT name="ULAN">P</DAT>
<DAT name="UDESCR" xml:space='preserve'>Levenshtein distance</DAT>
<DAT name="UTEXT" xml:space='preserve'>entry get_Levenshtein
   ; calculate the levenstein distance between two strings 
   ; https://en.wikipedia.org/wiki/Levenshtein_distance
   ; http://planetcalc.com/1721/
   ; basically we are determining in how many steps we could transform string1 into string2
   ; @requires : USTRING:STRING2LIST
   ; @version 1.0.0
   returns numeric 
   params 
      string p_source : in
      string p_target : in
   endparams 
   variables 
      string v_string, v_char, v_source, v_not_found, v_found, v_item
      string v_curr, v_next, v_prev
      numeric v_pointer, v_distance, v_lt, v_ls, v_nrnext, v_nrprev
   endvariables 

   ; init 
   v_ls = $length(p_source)
   v_lt = $length(p_target)
   ; turn both to uppercase 
   p_source = $uppercase(p_source)
   p_target = $uppercase(p_target)

   ; determine what we need to add 
   v_distance =  $abs(v_lt - v_ls)
   ; if one is empty we are done 
   if (v_ls = 0 || v_lt = 0) 
      return v_distance 
   endif 

   ; try to fit the smallest in the biggest
   if (v_ls &gt; v_lt)
      ; switch 
      v_source = p_source 
      p_source = p_target 
      p_target = v_source
      v_source = ""
      v_ls = $length(p_source)
      v_lt = $length(p_target)
   endif 

   ; try to match as much as possible in a string 
   ; look for a single character in the string and build from that 
   ; single characters should be matched at the end.

   ; turn the string into a list 
   ; use the list function that must exist somewhere
   v_source = string2List(p_source, "")

   ; make a list of matching elements 

;   v_pointer = 1
;   while (v_pointer &lt; $itemcount(v_source))
   while (v_source != "")

;      getitem v_char, v_source, v_pointer
      getitem v_char, v_source, 1
      v_string = v_char
      
      while ($scan(p_target, v_string) &gt; 0)
         delitem v_source, 1
         if (v_source = "") 
            break
         else 
;            getitem v_char, v_source, v_pointer
            getitem v_char, v_source, 1
            v_string = $concat(v_string, v_char)
         endif 

;         ; concat the string in the list 
;         v_source = $replace(v_source, 1, $concat(v_item, "&uSEP;"), v_item, 1)

      endwhile 
      ; source is either emtpy or we stumbled across a mismatch 
      if (v_char != "" &amp;&amp; v_source !="")
         ; mismatch 
         ; remove the last character 
         v_string = v_string[1, $length(v_string) -1]
      endif 
      if (v_string != "")
         ; we found a match 
         putitem v_found, -1, v_string 
         v_string = ""
      else 
         ; string is empty
         if (v_char != "") 
            putitem v_not_found, -1, v_char
            delitem v_source, 1
         endif 
      endif 
   
;      v_pointer = 1    
   endwhile

   ; we have a found and a not found string 
   ; now see if the things we found are in the same order 
   ; if not remove them 
   v_pointer = 1
   while (v_pointer &lt;= $itemcount(v_found))

      getitem v_curr, v_found, v_pointer
      if (v_pointer != $itemcount(v_found))
         getitem v_next, v_found, (v_pointer+1)
         v_nrnext = $scan(p_target, v_next)
      else 
         v_nrnext = $length(p_target)
      endif 
      if (v_pointer != 1)
         getitem v_prev, v_found, (v_pointer-1)
         v_nrprev = $scan(p_target, v_prev) + $length(v_prev) -1
      else 
         v_nrprev = 0
      endif 

      if ($scan(p_target, v_curr) &gt; v_nrprev  &amp;&amp;  $scan (p_target, v_curr) &lt; v_nrnext)
         ;  it should be between the previous and the next
      elseif ($scan(p_target, v_curr) &gt; v_nrprev)
         ; it must be at least after the next one 
      else 
         ; we throw it out 
         putitem v_not_found, -1, v_curr
         delitem v_found, v_pointer
         v_pointer -= 1
      endif 
      v_pointer +=1
   endwhile 
   

   ; remove the seperators and calculate the number 
   v_not_found = $replace(v_not_found, 1, "&uSEP;", "", -1)
   v_distance +=  $length(v_not_found)

   return v_distance
end ; get_Levenshtein
</DAT>
</OCC>
<OCC>
<DAT name="UTIMESTAMP">2014-10-19T17:43:48.00</DAT>
<DAT name="USUB">I</DAT>
<DAT name="UVAR">USTRING</DAT>
<DAT name="ULABEL">LIST2STRING</DAT>
<DAT name="ULAN">P</DAT>
<DAT name="UDESCR" xml:space='preserve'>Turn a list into a string</DAT>
<DAT name="UTEXT" xml:space='preserve'>entry list2String
   ; @description = Create a string from the list
   ; @params = p_list can be a list. It cannot be a key-valuepair list or a list within a list. p_case can be any string. p_found returns the string with the items as orderd in the list, separated by a value of the separation string. 
   ; @version = 0.1
   ; @date = 2014-01-08
   ; @author = Dennis E.J. Vorst
   ; 
   params
      string p_list      : in 
      string p_separator : in
      string p_string    : out
   endparams
   variables
      string v_item
   endvariables 

   ; prerequisites 
   if (p_list = "")
;      message/nobeep "IP_LISTTOSTRING - Empty string."
      return(0)
   endif 
   if ($scan(p_list, "=") &gt; 0)
      message/nobeep "IP_LISTTOSTRING - List entered contains key-valuepairs."
      return(0)      
   endif 
   if ($scan(p_list, "&uNOT;&uSEP;") &gt; 0)
      message/nobeep "IP_LISTTOSTRING - List entered contains lists within lists."
      return(0)      
   endif 

   ; the actual processing
   forlist v_item in p_list
      p_string = $concat(p_string, v_item, p_separator)
   endfor

   ; cut the separator from the end of the string 
   p_string = $rtrim(p_string, p_separator)

   return(0)
end ; list2String
</DAT>
</OCC>
<OCC>
<DAT name="UTIMESTAMP">2014-11-02T08:06:52.00</DAT>
<DAT name="USUB">I</DAT>
<DAT name="UVAR">USTRING</DAT>
<DAT name="ULABEL">NUMBER2ALPHABET</DAT>
<DAT name="ULAN">P</DAT>
<DAT name="UTEXT" xml:space='preserve'>entry number2Alphabet
   ; @description = convert a numeric value to its alfabetic value
   ; @author = Dennis E.J. Vorst 
   ; @issues = put the items in list with key value pairs
   params 
      numeric p_value : in
      string  p_char  : out
   endparams 
   variables 
      string v_ftlist
   endvariables 

   if (p_value &lt; 1 | p_value &gt; 26)
      message "Value must be 1 through 26. Illegal value %%p_value%%% entered"
      return(-1)
   endif

   putitem/id v_ftlist, 1, "A"
   putitem/id v_ftlist, 2, "B"
   putitem/id v_ftlist, 3, "C"
   putitem/id v_ftlist, 4, "D"
   putitem/id v_ftlist, 5, "E"
   putitem/id v_ftlist, 6, "F"
   putitem/id v_ftlist, 7, "G"
   putitem/id v_ftlist, 8, "H"
   putitem/id v_ftlist, 9, "I"
   putitem/id v_ftlist, 10, "J"
   putitem/id v_ftlist, 11, "K"
   putitem/id v_ftlist, 12, "L"
   putitem/id v_ftlist, 13, "M"
   putitem/id v_ftlist, 14, "N"
   putitem/id v_ftlist, 15, "O"
   putitem/id v_ftlist, 16, "P"
   putitem/id v_ftlist, 17, "Q"
   putitem/id v_ftlist, 18, "R"
   putitem/id v_ftlist, 19, "S"
   putitem/id v_ftlist, 20, "T"
   putitem/id v_ftlist, 21, "U"
   putitem/id v_ftlist, 22, "V"
   putitem/id v_ftlist, 23, "W"
   putitem/id v_ftlist, 24, "X"
   putitem/id v_ftlist, 25, "Y"
   putitem/id v_ftlist, 26, "Z"

   p_char = $item(p_value, v_ftlist)

   return(0)
end ; number2Alphabet</DAT>
</OCC>
<OCC>
<DAT name="UTIMESTAMP">2014-10-19T17:38:05.00</DAT>
<DAT name="USUB">I</DAT>
<DAT name="UVAR">USTRING</DAT>
<DAT name="ULABEL">REPLACEALL</DAT>
<DAT name="ULAN">P</DAT>
<DAT name="UDESCR" xml:space='preserve'>Replace all values</DAT>
<DAT name="UTEXT" xml:space='preserve'>entry replaceAll
   ; @name = replaceAll
   ; @description = replace all the values in a string in a while loop until there are none left
   ; @version = 0.1
   ; @date = 2014-01-08
   ; @company = Vorst Informatisering
   ; @author = Dennis E.J. Vorst
   params
      string p_string  : inout 
      string p_search  : in
      string p_replace : in 
   endparams 

   while ($scan(p_string, p_search) &gt; 0)
      p_string = $replace(p_string, 1, p_search, p_replace, -1)
   endwhile 

   return(0)
end ; replaceAll
</DAT>
</OCC>
<OCC>
<DAT name="UTIMESTAMP">2015-09-14T16:09:23.00</DAT>
<DAT name="USUB">I</DAT>
<DAT name="UVAR">USTRING</DAT>
<DAT name="ULABEL">STRING2LIST</DAT>
<DAT name="ULAN">P</DAT>
<DAT name="UDESCR" xml:space='preserve'>Turn a string into a list</DAT>
<DAT name="UTEXT" xml:space='preserve'>entry string2List
   ; @description = Create a list from a string
   ; @params = p_string can be a string. p_list returns a list of the string separated at the places where the separator was found.
   ; @version = 1.0.1
   ; @date = 2014-01-08
   ; @author = Dennis E.J. Vorst
   ; @history : changed the entry so that it turns a string into a list even when there is no spereator provided. This will result in a list of single characters. 
   returns string 
   params
      string p_string    : in 
      string p_separator : in
   endparams
   variables
      string v_item, v_list
      numeric v_pointer
   endvariables 

   ; prerequisites 
   if (p_string = "")
;      message/nobeep "IP_STRINGTOLIST - Empty string."
      return(0)
   endif 
   if ($scan(p_string, "&uSEP;") &gt; 0)
      message/nobeep "IP_STRINGTOLIST - String entered is already a list."
      return(0)      
   endif 
   if ($scan(p_separator, "&uSEP;") &gt; 0)
      message/nobeep "IP_STRINGTOLIST - Separator cannot be &lt;gold&gt; + ;&gt;."
      return(0)      
   endif 

   ; the actual processing
   if (p_separator != "")
      v_list = $replace(p_string, 1, p_separator, "&uSEP;", -1)
   else 
      v_pointer = 1
      while (v_pointer &lt;= $length(p_string))
         putitem v_list, -1, p_string[v_pointer:1]
         ; next 
         v_pointer += 1
      endwhile 
   endif 

   return v_list
end ; string2List</DAT>
</OCC>
<OCC>
<DAT name="UTIMESTAMP">2015-09-14T16:07:02.00</DAT>
<DAT name="USUB">I</DAT>
<DAT name="UVAR">USTRING</DAT>
<DAT name="ULABEL">STRINGLIST</DAT>
<DAT name="ULAN">P</DAT>
<DAT name="UTEXT" xml:space='preserve'>entry stringList
   ; @description = Return a list of string values that represent the values given in the corresponding string value.
   ; @params
   ; p_string can be any string. 
   ; p_case can be either true (case sensitive) or false (case insensitive). 
   ; p_list contains the starting locations of the string.
   ; @version = 0.1
   ; @date = 2014-01-08
   ; @author = Dennis E.J. Vorst
   params 
      string  p_string : in 
      string  p_search : in
      boolean p_case   : in
      string  p_list   : out
   endparams 
   variables 
      string v_item, v_list
      numeric v_length, v_pointer
   endvariables 

   ; init 
   v_length = $length(p_search)

   ; get a list of starting points in the codestring  
   call IP_STRING_LOCATIONS(p_string, p_search, p_case, 1, v_list)
   #include MATERIAL:ERR_CALL

   forlist v_pointer in v_list
      v_item = p_string[v_pointer, v_length + v_pointer - 1]
      putitem p_list, -1, v_item      
   endfor
   return(0)
end ; stringList</DAT>
</OCC>
</TABLE>
</UNIFACE>
